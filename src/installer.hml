// hpm - Package installer (downloads, extracts, installs packages)

import { exists, read_file, read_file_binary, write_file, make_dir, remove_dir, list_dir, is_dir } from "@stdlib/fs";
import { sha256 } from "@stdlib/hash";
import { fork, waitpid, exec } from "@stdlib/process";
import { exit } from "@stdlib/env";

import * as github from "./github.hml";
import * as cache from "./cache.hml";
import * as manifest from "./manifest.hml";
import * as log from "./log.hml";

// Maximum number of parallel downloads
let MAX_PARALLEL_DOWNLOADS = 4;

// Base64 alphabet for encoding
let BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Calculate SHA256 integrity hash for a file
// Returns string in format "sha256-<base64hash>"
fn calculate_file_integrity(file_path: string): string {
    log.debug("Calculating SHA256 integrity for: " + file_path);

    // Read file as binary
    let content = read_file_binary(file_path);
    if (content == null) {
        log.warn("Failed to read file for integrity check: " + file_path);
        return "sha256-unknown";
    }

    // Calculate SHA256 hash (returns hex string)
    let hash_hex = sha256(content);
    log.debug("SHA256 hex: " + hash_hex);

    // Convert hex to bytes then to base64
    let hash_base64 = hex_to_base64(hash_hex);
    log.debug("SHA256 base64: " + hash_base64);

    return "sha256-" + hash_base64;
}

// Convert hex string to base64
fn hex_to_base64(hex: string): string {
    // Convert hex to bytes
    let bytes = [];
    let i = 0;
    while (i < hex.length) {
        let high = hex_char_to_int(hex[i]);
        let low = hex_char_to_int(hex[i + 1]);
        bytes.push(high * 16 + low);
        i = i + 2;
    }

    // Convert bytes to base64
    let result = "";
    i = 0;
    while (i < bytes.length) {
        let b1 = bytes[i];
        let b2 = 0;
        let b3 = 0;
        let padding = 0;

        if (i + 1 < bytes.length) {
            b2 = bytes[i + 1];
        } else {
            padding = 2;
        }

        if (i + 2 < bytes.length) {
            b3 = bytes[i + 2];
        } else if (padding == 0) {
            padding = 1;
        }

        // Encode 3 bytes into 4 base64 characters
        let c1 = b1 >> 2;
        let c2 = ((b1 & 3) << 4) | (b2 >> 4);
        let c3 = ((b2 & 15) << 2) | (b3 >> 6);
        let c4 = b3 & 63;

        result = result + BASE64_ALPHABET[c1];
        result = result + BASE64_ALPHABET[c2];

        if (padding == 2) {
            result = result + "==";
        } else if (padding == 1) {
            result = result + BASE64_ALPHABET[c3] + "=";
        } else {
            result = result + BASE64_ALPHABET[c3];
            result = result + BASE64_ALPHABET[c4];
        }

        i = i + 3;
    }

    return result;
}

// Convert hex character to integer
fn hex_char_to_int(ch: rune): i32 {
    if (ch >= '0' && ch <= '9') {
        let result: i32 = ch;
        return result - 48;  // '0' is ASCII 48
    }
    if (ch >= 'a' && ch <= 'f') {
        let result: i32 = ch;
        return result - 87;  // 'a' is ASCII 97, 97-87=10
    }
    if (ch >= 'A' && ch <= 'F') {
        let result: i32 = ch;
        return result - 55;  // 'A' is ASCII 65, 65-55=10
    }
    return 0;
}

// Install a resolved package to hem_modules
// Set offline=true to install only from cache (no network requests)
export fn install_package(pkg_name: string, resolution, project_dir: string, verbose: bool, offline: bool) {
    let parts = manifest.split_name(pkg_name);
    if (parts == null) {
        throw "Invalid package name: " + pkg_name;
    }

    let owner = parts.owner;
    let repo = parts.repo;
    let version = resolution.version;

    // Add 'v' prefix for version if not present (for GitHub tags)
    let tag_version = version;
    if (tag_version.length > 0 && tag_version[0] != 'v') {
        tag_version = "v" + tag_version;
    }

    if (verbose) {
        print("  Installing " + pkg_name + "@" + version);
    }

    // Check cache first
    let tarball_path = null;
    if (cache.is_cached(owner, repo, version)) {
        if (verbose) {
            print("    Using cached tarball");
        }
        tarball_path = cache.get_cached_path(owner, repo, version);
    } else {
        // In offline mode, fail if not in cache
        if (offline) {
            throw "Package " + pkg_name + "@" + version + " not found in cache (offline mode)";
        }

        // Download tarball to temp file
        if (verbose) {
            print("    Downloading from GitHub...");
        }
        tarball_path = github.download_tarball(owner, repo, tag_version);

        // Store in cache (copy the downloaded file)
        cache.store_tarball_file(owner, repo, version, tarball_path);
    }

    // Extract using tar command (handles binary gzip correctly)
    if (verbose) {
        print("    Extracting...");
    }

    // Create installation directory
    let install_dir = project_dir + "/hem_modules/" + owner + "/" + repo;
    ensure_dir_recursive(project_dir + "/hem_modules");
    ensure_dir_recursive(project_dir + "/hem_modules/" + owner);

    // Remove existing installation if present
    if (exists(install_dir)) {
        remove_dir_recursive(install_dir);
    }
    make_dir(install_dir);

    // Create temp extraction dir
    let extract_dir = "/tmp/hpm_extract_" + owner + "_" + repo + "_" + version;
    if (exists(extract_dir)) {
        remove_dir_recursive(extract_dir);
    }
    make_dir(extract_dir);

    // Extract tarball using system tar
    let tar_cmd = "tar -xzf '" + tarball_path + "' -C '" + extract_dir + "'";
    let tar_result = exec(tar_cmd);
    if (tar_result.exit_code != 0) {
        throw "Failed to extract tarball: tar exited with status " + tar_result.exit_code;
    }

    // Find the extracted directory (GitHub tarballs have a root dir like "repo-version/")
    let extracted_dirs = list_dir(extract_dir);
    if (extracted_dirs.length == 0) {
        throw "Failed to extract tarball: no files extracted";
    }
    let root_dir = extract_dir + "/" + extracted_dirs[0];

    // Copy contents to install_dir
    let copy_cmd = "cp -r '" + root_dir + "/.' '" + install_dir + "'";
    let copy_result = exec(copy_cmd);
    if (copy_result.exit_code != 0) {
        throw "Failed to copy extracted files";
    }

    // Clean up temp extraction dir
    remove_dir_recursive(extract_dir);

    // Calculate integrity from tarball file
    let integrity = calculate_file_integrity(tarball_path);
    if (verbose) {
        print("    Integrity: " + integrity);
    }

    return integrity;
}

// Helper to find last occurrence of character
fn find_last(s: string, ch: rune): i32 {
    let last = -1;
    let i = 0;
    while (i < s.length) {
        if (s[i] == ch) {
            last = i;
        }
        i = i + 1;
    }
    return last;
}

// Ensure directory exists recursively
fn ensure_dir_recursive(path: string) {
    if (exists(path)) {
        return;
    }

    let parts = path.split("/");
    let current = "";

    let i = 0;
    while (i < parts.length) {
        let part = parts[i];
        if (part.length > 0) {
            if (current.length == 0 && path[0] == '/') {
                current = "/" + part;
            } else if (current.length == 0) {
                current = part;
            } else {
                current = current + "/" + part;
            }

            if (!exists(current)) {
                make_dir(current);
            }
        }
        i = i + 1;
    }
}

// Remove directory recursively
fn remove_dir_recursive(path: string) {
    if (!exists(path)) {
        return;
    }

    if (!is_dir(path)) {
        remove_file(path);
        return;
    }

    // List and remove contents
    let entries = list_dir(path);
    let i = 0;
    while (i < entries.length) {
        let entry = entries[i];
        let entry_path = path + "/" + entry;
        if (is_dir(entry_path)) {
            remove_dir_recursive(entry_path);
        } else {
            remove_file(entry_path);
        }
        i = i + 1;
    }

    // Remove the directory itself
    remove_dir(path);
}

// Import remove_file from fs
import { remove_file } from "@stdlib/fs";

// Prefetch packages to cache in parallel (download only, no extraction)
fn prefetch_packages(resolved, verbose: bool) {
    let keys = resolved.keys();
    let to_download = [];

    // Build list of packages not in cache
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let resolution = resolved.get(pkg_name);
        let parts = manifest.split_name(pkg_name);

        if (parts != null) {
            let version = resolution.version;
            if (!cache.is_cached(parts.owner, parts.repo, version)) {
                to_download.push({
                    name: pkg_name,
                    owner: parts.owner,
                    repo: parts.repo,
                    version: version
                });
            }
        }
        i = i + 1;
    }

    if (to_download.length == 0) {
        if (verbose) {
            print("  All packages in cache");
        }
        return;
    }

    if (verbose) {
        print("  Downloading " + to_download.length + " package(s) in parallel...");
    }

    // Download in batches of MAX_PARALLEL_DOWNLOADS
    i = 0;
    while (i < to_download.length) {
        let batch_end = i + MAX_PARALLEL_DOWNLOADS;
        if (batch_end > to_download.length) {
            batch_end = to_download.length;
        }

        // Fork child processes for this batch
        let pids = [];
        let j = i;
        while (j < batch_end) {
            let pkg = to_download[j];
            let pid = fork();

            if (pid == 0) {
                // Child process - download and cache
                try {
                    let tag_version = pkg.version;
                    if (tag_version.length > 0 && tag_version[0] != 'v') {
                        tag_version = "v" + tag_version;
                    }
                    let tarball_path = github.download_tarball(pkg.owner, pkg.repo, tag_version);
                    cache.store_tarball_file(pkg.owner, pkg.repo, pkg.version, tarball_path);
                    exit(0);
                } catch (e) {
                    exit(1);
                }
            } else {
                // Parent - track child pid
                pids.push({ pid: pid, pkg: pkg });
            }
            j = j + 1;
        }

        // Wait for all children in this batch
        j = 0;
        while (j < pids.length) {
            let status = waitpid(pids[j].pid);
            if (status != 0 && verbose) {
                print("    Warning: Failed to download " + pids[j].pkg.name);
            }
            j = j + 1;
        }

        i = batch_end;
    }
}

// Install all resolved packages
// Set offline=true to install only from cache (no network requests)
// Set parallel=true to download packages in parallel before extraction
export fn install_all(resolved, project_dir: string, lockfile, verbose: bool, offline: bool, parallel: bool) {
    // Prefetch packages to cache in parallel (unless offline)
    if (!offline && parallel) {
        prefetch_packages(resolved, verbose);
    }

    let keys = resolved.keys();
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let resolution = resolved.get(pkg_name);

        // Install the package
        let integrity = install_package(pkg_name, resolution, project_dir, verbose, offline);

        // Update resolution with integrity
        resolution.integrity = integrity;
        resolved.set(pkg_name, resolution);

        i = i + 1;
    }

    return resolved;
}

// Uninstall a package from hem_modules
export fn uninstall_package(pkg_name: string, project_dir: string, verbose: bool) {
    let parts = manifest.split_name(pkg_name);
    if (parts == null) {
        throw "Invalid package name: " + pkg_name;
    }

    let owner = parts.owner;
    let repo = parts.repo;

    let install_dir = project_dir + "/hem_modules/" + owner + "/" + repo;

    if (!exists(install_dir)) {
        if (verbose) {
            print("  Package " + pkg_name + " not installed");
        }
        return false;
    }

    if (verbose) {
        print("  Removing " + pkg_name);
    }

    remove_dir_recursive(install_dir);

    // Clean up empty owner directory
    let owner_dir = project_dir + "/hem_modules/" + owner;
    let remaining = list_dir(owner_dir);
    if (remaining.length == 0) {
        remove_dir(owner_dir);
    }

    return true;
}

// Check what packages are currently installed
export fn get_installed(project_dir: string) {
    let installed = [];
    let modules_dir = project_dir + "/hem_modules";

    if (!exists(modules_dir)) {
        return installed;
    }

    // List owners
    let owners = list_dir(modules_dir);
    let i = 0;
    while (i < owners.length) {
        let owner = owners[i];
        let owner_path = modules_dir + "/" + owner;

        if (is_dir(owner_path)) {
            // List repos
            let repos = list_dir(owner_path);
            let j = 0;
            while (j < repos.length) {
                let repo = repos[j];
                let repo_path = owner_path + "/" + repo;

                if (is_dir(repo_path)) {
                    // Check for package.json to get version
                    let pkg_json_path = repo_path + "/package.json";
                    let version = "unknown";

                    if (exists(pkg_json_path)) {
                        try {
                            let pkg = manifest.read_manifest(repo_path);
                            if (pkg != null && pkg.version != null) {
                                version = pkg.version;
                            }
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }

                    installed.push({
                        name: owner + "/" + repo,
                        version: version,
                        path: repo_path
                    });
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }

    return installed;
}

// Verify integrity of installed packages
// Checks both installation existence and cached tarball integrity
export fn verify_integrity(project_dir: string, lockfile) {
    let issues = [];

    if (lockfile == null || lockfile.dependencies == null) {
        return issues;
    }

    let keys = lockfile.dependencies.keys();
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let entry = lockfile.dependencies[pkg_name];
        let parts = manifest.split_name(pkg_name);

        if (parts != null) {
            let install_dir = project_dir + "/hem_modules/" + parts.owner + "/" + parts.repo;

            // Check if package is installed
            if (!exists(install_dir)) {
                issues.push({
                    package: pkg_name,
                    issue: "not installed"
                });
            }

            // Verify integrity against cached tarball if we have a recorded hash
            if (entry.integrity != null && entry.integrity != "" && entry.integrity != "sha256-unknown") {
                let cached_path = cache.get_cached_path(parts.owner, parts.repo, entry.version);
                if (cached_path != null && exists(cached_path)) {
                    let actual_integrity = calculate_file_integrity(cached_path);
                    if (actual_integrity != entry.integrity) {
                        log.warn("Integrity mismatch for " + pkg_name);
                        log.debug("Expected: " + entry.integrity);
                        log.debug("Actual: " + actual_integrity);
                        issues.push({
                            package: pkg_name,
                            issue: "integrity mismatch",
                            expected: entry.integrity,
                            actual: actual_integrity
                        });
                    }
                }
            }
        }

        i = i + 1;
    }

    return issues;
}
