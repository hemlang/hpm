// hpm - Package installer (downloads, extracts, installs packages)

import { exists, read_file, write_file, make_dir, remove_dir, list_dir, is_dir } from "@stdlib/fs";
import { sha256 } from "@stdlib/hash";
import { fork, waitpid, exec, get_pid } from "@stdlib/process";
import { exit } from "@stdlib/env";
import { now } from "@stdlib/time";

import * as github from "./github.hml";
import * as cache from "./cache.hml";
import * as manifest from "./manifest.hml";

// Maximum number of parallel downloads
let MAX_PARALLEL_DOWNLOADS = 4;

// Generate a unique suffix for temp directories using PID and timestamp
fn unique_suffix(): string {
    let pid = get_pid();
    let ts = now();
    return "" + pid + "_" + ts;
}

// Install a resolved package to hem_modules
// Set offline=true to install only from cache (no network requests)
export fn install_package(pkg_name: string, resolution, project_dir: string, verbose: bool, offline: bool) {
    let parts = manifest.split_name(pkg_name);
    if (parts == null) {
        throw "Invalid package name: " + pkg_name;
    }

    let owner = parts.owner;
    let repo = parts.repo;
    let version = resolution.version;

    // Add 'v' prefix for version if not present (for GitHub tags)
    let tag_version = version;
    if (tag_version.length > 0 && tag_version[0] != 'v') {
        tag_version = "v" + tag_version;
    }

    if (verbose) {
        print("  Installing " + pkg_name + "@" + version);
    }

    // Check cache first
    let tarball_path = null;
    if (cache.is_cached(owner, repo, version)) {
        if (verbose) {
            print("    Using cached tarball");
        }
        tarball_path = cache.get_cached_path(owner, repo, version);
    } else {
        // In offline mode, fail if not in cache
        if (offline) {
            throw "Package " + pkg_name + "@" + version + " not found in cache (offline mode)";
        }

        // Download tarball to temp file
        if (verbose) {
            print("    Downloading from GitHub...");
        }
        tarball_path = github.download_tarball(owner, repo, tag_version);

        // Store in cache (copy the downloaded file)
        cache.store_tarball_file(owner, repo, version, tarball_path);
    }

    // Extract using tar command (handles binary gzip correctly)
    if (verbose) {
        print("    Extracting...");
    }

    // Create installation directory
    let install_dir = project_dir + "/hem_modules/" + owner + "/" + repo;
    ensure_dir_recursive(project_dir + "/hem_modules");
    ensure_dir_recursive(project_dir + "/hem_modules/" + owner);

    // Remove existing installation if present
    if (exists(install_dir)) {
        remove_dir_recursive(install_dir);
    }
    make_dir(install_dir);

    // Create temp extraction dir with unique suffix to avoid race conditions
    let extract_dir = "/tmp/hpm_extract_" + owner + "_" + repo + "_" + version + "_" + unique_suffix();
    if (exists(extract_dir)) {
        remove_dir_recursive(extract_dir);
    }
    make_dir(extract_dir);

    // Extract tarball using system tar
    let tar_result = exec("tar -xzf " + tarball_path + " -C " + extract_dir);
    if (tar_result.exit_code != 0) {
        throw "Failed to extract tarball: tar exited with status " + tar_result.exit_code;
    }

    // Find the extracted directory (GitHub tarballs have a root dir like "repo-version/")
    let extracted_dirs = list_dir(extract_dir);
    if (extracted_dirs.length == 0) {
        throw "Failed to extract tarball: no files extracted";
    }
    let root_dir = extract_dir + "/" + extracted_dirs[0];

    // Copy contents to install_dir
    let copy_result = exec("cp -r " + root_dir + "/. " + install_dir);
    if (copy_result.exit_code != 0) {
        throw "Failed to copy extracted files";
    }

    // Clean up temp extraction dir
    remove_dir_recursive(extract_dir);

    // Calculate integrity from tarball file
    let integrity = "sha256-unknown";
    try {
        let tarball_content = read_file(tarball_path);
        if (tarball_content != null) {
            let hash = sha256(tarball_content);
            integrity = "sha256-" + hash;
        }
    } catch (e) {
        // Keep unknown integrity if calculation fails
    }

    return integrity;
}

// Helper to find last occurrence of character
fn find_last(s: string, ch: rune): i32 {
    let last = -1;
    let i = 0;
    while (i < s.length) {
        if (s[i] == ch) {
            last = i;
        }
        i = i + 1;
    }
    return last;
}

// Ensure directory exists recursively
fn ensure_dir_recursive(path: string) {
    if (exists(path)) {
        return;
    }

    let parts = path.split("/");
    let current = "";

    let i = 0;
    while (i < parts.length) {
        let part = parts[i];
        if (part.length > 0) {
            if (current.length == 0 && path[0] == '/') {
                current = "/" + part;
            } else if (current.length == 0) {
                current = part;
            } else {
                current = current + "/" + part;
            }

            if (!exists(current)) {
                make_dir(current);
            }
        }
        i = i + 1;
    }
}

// Remove directory recursively
fn remove_dir_recursive(path: string) {
    if (!exists(path)) {
        return;
    }

    if (!is_dir(path)) {
        remove_file(path);
        return;
    }

    // List and remove contents
    let entries = list_dir(path);
    let i = 0;
    while (i < entries.length) {
        let entry = entries[i];
        let entry_path = path + "/" + entry;
        if (is_dir(entry_path)) {
            remove_dir_recursive(entry_path);
        } else {
            remove_file(entry_path);
        }
        i = i + 1;
    }

    // Remove the directory itself
    remove_dir(path);
}

// Import remove_file from fs
import { remove_file } from "@stdlib/fs";

// Prefetch packages to cache in parallel (download only, no extraction)
fn prefetch_packages(resolved, verbose: bool) {
    let keys = resolved.keys();
    let to_download = [];

    // Build list of packages not in cache
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let resolution = resolved.get(pkg_name);
        let parts = manifest.split_name(pkg_name);

        if (parts != null) {
            let version = resolution.version;
            if (!cache.is_cached(parts.owner, parts.repo, version)) {
                to_download.push({
                    name: pkg_name,
                    owner: parts.owner,
                    repo: parts.repo,
                    version: version
                });
            }
        }
        i = i + 1;
    }

    if (to_download.length == 0) {
        if (verbose) {
            print("  All packages in cache");
        }
        return;
    }

    if (verbose) {
        print("  Downloading " + to_download.length + " package(s) in parallel...");
    }

    // Download in batches of MAX_PARALLEL_DOWNLOADS
    i = 0;
    while (i < to_download.length) {
        let batch_end = i + MAX_PARALLEL_DOWNLOADS;
        if (batch_end > to_download.length) {
            batch_end = to_download.length;
        }

        // Fork child processes for this batch
        let pids = [];
        let j = i;
        while (j < batch_end) {
            let pkg = to_download[j];
            let pid = fork();

            if (pid == 0) {
                // Child process - download and cache
                try {
                    let tag_version = pkg.version;
                    if (tag_version.length > 0 && tag_version[0] != 'v') {
                        tag_version = "v" + tag_version;
                    }
                    let tarball_path = github.download_tarball(pkg.owner, pkg.repo, tag_version);
                    cache.store_tarball_file(pkg.owner, pkg.repo, pkg.version, tarball_path);
                    exit(0);
                } catch (e) {
                    exit(1);
                }
            } else {
                // Parent - track child pid
                pids.push({ pid: pid, pkg: pkg });
            }
            j = j + 1;
        }

        // Wait for all children in this batch
        j = 0;
        while (j < pids.length) {
            let status = waitpid(pids[j].pid);
            if (status != 0 && verbose) {
                print("    Warning: Failed to download " + pids[j].pkg.name);
            }
            j = j + 1;
        }

        i = batch_end;
    }
}

// Install all resolved packages
// Set offline=true to install only from cache (no network requests)
// Set parallel=true to download packages in parallel before extraction
export fn install_all(resolved, project_dir: string, lockfile, verbose: bool, offline: bool, parallel: bool) {
    // Prefetch packages to cache in parallel (unless offline)
    if (!offline && parallel) {
        prefetch_packages(resolved, verbose);
    }

    let keys = resolved.keys();
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let resolution = resolved.get(pkg_name);

        // Install the package
        let integrity = install_package(pkg_name, resolution, project_dir, verbose, offline);

        // Update resolution with integrity
        resolution.integrity = integrity;
        resolved.set(pkg_name, resolution);

        i = i + 1;
    }

    return resolved;
}

// Uninstall a package from hem_modules
export fn uninstall_package(pkg_name: string, project_dir: string, verbose: bool) {
    let parts = manifest.split_name(pkg_name);
    if (parts == null) {
        throw "Invalid package name: " + pkg_name;
    }

    let owner = parts.owner;
    let repo = parts.repo;

    let install_dir = project_dir + "/hem_modules/" + owner + "/" + repo;

    if (!exists(install_dir)) {
        if (verbose) {
            print("  Package " + pkg_name + " not installed");
        }
        return false;
    }

    if (verbose) {
        print("  Removing " + pkg_name);
    }

    remove_dir_recursive(install_dir);

    // Clean up empty owner directory
    let owner_dir = project_dir + "/hem_modules/" + owner;
    let remaining = list_dir(owner_dir);
    if (remaining.length == 0) {
        remove_dir(owner_dir);
    }

    return true;
}

// Check what packages are currently installed
export fn get_installed(project_dir: string) {
    let installed = [];
    let modules_dir = project_dir + "/hem_modules";

    if (!exists(modules_dir)) {
        return installed;
    }

    // List owners
    let owners = list_dir(modules_dir);
    let i = 0;
    while (i < owners.length) {
        let owner = owners[i];
        let owner_path = modules_dir + "/" + owner;

        if (is_dir(owner_path)) {
            // List repos
            let repos = list_dir(owner_path);
            let j = 0;
            while (j < repos.length) {
                let repo = repos[j];
                let repo_path = owner_path + "/" + repo;

                if (is_dir(repo_path)) {
                    // Check for package.json to get version
                    let pkg_json_path = repo_path + "/package.json";
                    let version = "unknown";

                    if (exists(pkg_json_path)) {
                        try {
                            let pkg = manifest.read_manifest(repo_path);
                            if (pkg != null && pkg.version != null) {
                                version = pkg.version;
                            }
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }

                    installed.push({
                        name: owner + "/" + repo,
                        version: version,
                        path: repo_path
                    });
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }

    return installed;
}

// Verify integrity of installed packages
export fn verify_integrity(project_dir: string, lockfile) {
    let issues = [];

    if (lockfile == null || lockfile.dependencies == null) {
        return issues;
    }

    let keys = lockfile.dependencies.keys();
    let i = 0;
    while (i < keys.length) {
        let pkg_name = keys[i];
        let entry = lockfile.dependencies[pkg_name];
        let parts = manifest.split_name(pkg_name);

        if (parts != null) {
            let install_dir = project_dir + "/hem_modules/" + parts.owner + "/" + parts.repo;

            if (!exists(install_dir)) {
                issues.push({
                    package: pkg_name,
                    issue: "not installed"
                });
            }
            // Note: Full integrity verification would require re-downloading
            // and comparing hashes, which is expensive. Skip for now.
        }

        i = i + 1;
    }

    return issues;
}
