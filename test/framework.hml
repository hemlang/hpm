// Simple test framework for hpm

import { fork, waitpid_timeout, kill } from "@stdlib/process";
import { exit } from "@stdlib/env";

let tests_run = 0;
let tests_passed = 0;
let tests_failed = 0;
let tests_skipped = 0;
let current_suite = "";

// Default timeout for tests (30 seconds)
let DEFAULT_TIMEOUT_MS = 30000;

// Start a test suite
export fn suite(name: string) {
    current_suite = name;
    print("");
    print("=== " + name + " ===");
}

// Run a single test
export fn test(name: string, test_fn) {
    tests_run = tests_run + 1;
    let full_name = name;
    if (current_suite.length > 0) {
        full_name = current_suite + " > " + name;
    }

    try {
        test_fn();
        tests_passed = tests_passed + 1;
        print("  [PASS] " + name);
    } catch (e) {
        tests_failed = tests_failed + 1;
        print("  [FAIL] " + name);
        print("         " + e);
    }
}

// Run a test with a timeout (for integration tests that may hang)
// timeout_ms: maximum time in milliseconds before the test is killed
export fn test_with_timeout(name: string, test_fn, timeout_ms: i32) {
    tests_run = tests_run + 1;
    let full_name = name;
    if (current_suite.length > 0) {
        full_name = current_suite + " > " + name;
    }

    // Fork a child process to run the test
    let pid = fork();

    if (pid == 0) {
        // Child process - run the test
        try {
            test_fn();
            exit(0);  // Success
        } catch (e) {
            print("         " + e);
            exit(1);  // Failure
        }
    } else {
        // Parent process - wait with timeout
        let result = waitpid_timeout(pid, timeout_ms);

        if (result.timed_out) {
            // Test timed out - kill the child process
            kill(pid, 9);  // SIGKILL
            tests_failed = tests_failed + 1;
            print("  [TIMEOUT] " + name + " (exceeded " + timeout_ms + "ms)");
        } else if (result.exit_code == 0) {
            tests_passed = tests_passed + 1;
            print("  [PASS] " + name);
        } else {
            tests_failed = tests_failed + 1;
            print("  [FAIL] " + name);
        }
    }
}

// Skip a test (for tests that need external dependencies)
export fn skip(name: string, reason: string) {
    tests_skipped = tests_skipped + 1;
    print("  [SKIP] " + name + " (" + reason + ")");
}

// Assertion helpers
export fn assert(condition: bool, message: string) {
    if (!condition) {
        throw "Assertion failed: " + message;
    }
}

export fn assert_eq(actual, expected, message: string) {
    if (actual != expected) {
        throw "Assertion failed: " + message + " (expected " + expected + ", got " + actual + ")";
    }
}

export fn assert_neq(actual, expected, message: string) {
    if (actual == expected) {
        throw "Assertion failed: " + message + " (expected not " + expected + ")";
    }
}

export fn assert_null(value, message: string) {
    if (value != null) {
        throw "Assertion failed: " + message + " (expected null, got " + value + ")";
    }
}

export fn assert_not_null(value, message: string) {
    if (value == null) {
        throw "Assertion failed: " + message + " (expected non-null value)";
    }
}

export fn assert_true(value, message: string) {
    if (value != true) {
        throw "Assertion failed: " + message + " (expected true)";
    }
}

export fn assert_false(value, message: string) {
    if (value != false) {
        throw "Assertion failed: " + message + " (expected false)";
    }
}

export fn assert_throws(test_fn, message: string) {
    let threw = false;
    try {
        test_fn();
    } catch (e) {
        threw = true;
    }
    if (!threw) {
        throw "Assertion failed: " + message + " (expected exception)";
    }
}

// Print summary and return exit code
export fn summary(): i32 {
    print("");
    print("================================");
    let summary_line = "Tests: " + tests_run + " | Passed: " + tests_passed + " | Failed: " + tests_failed;
    if (tests_skipped > 0) {
        summary_line = summary_line + " | Skipped: " + tests_skipped;
    }
    print(summary_line);
    print("================================");

    if (tests_failed > 0) {
        print("");
        print("FAILED");
        return 1;
    }

    print("");
    print("ALL TESTS PASSED");
    return 0;
}

// Get counts for external use
export fn get_passed(): i32 {
    return tests_passed;
}

export fn get_failed(): i32 {
    return tests_failed;
}

export fn get_total(): i32 {
    return tests_run;
}

export fn get_skipped(): i32 {
    return tests_skipped;
}
