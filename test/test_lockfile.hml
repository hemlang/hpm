// Tests for lockfile module

import { suite, test, assert, assert_eq, assert_true, assert_false, assert_null, assert_not_null } from "./framework.hml";
import * as lockfile from "../src/lockfile.hml";

export fn run() {
    suite("lockfile.create_empty");

    test("creates empty lockfile", fn() {
        let lock = lockfile.create_empty();
        assert_eq(lock.lockVersion, 1, "lockVersion");
        assert_eq(lock.hemlock, "1.0.0", "hemlock");
        assert_not_null(lock.dependencies, "dependencies");
    });

    suite("lockfile.create_entry");

    test("creates entry with all fields", fn() {
        let deps = {};
        deps["other/pkg"] = "^1.0.0";
        let entry = lockfile.create_entry(
            "1.2.3",
            "https://github.com/owner/repo/archive/v1.2.3.tar.gz",
            "sha256-abc123",
            deps
        );

        assert_eq(entry.version, "1.2.3", "version");
        assert_eq(entry.resolved, "https://github.com/owner/repo/archive/v1.2.3.tar.gz", "resolved");
        assert_eq(entry.integrity, "sha256-abc123", "integrity");
        assert_not_null(entry.dependencies, "dependencies");
    });

    test("creates entry without deps", fn() {
        let entry = lockfile.create_entry("1.0.0", "url", "hash", null);
        assert_eq(entry.version, "1.0.0", "version");
        // When no deps passed, the dependencies field is not set
    });

    suite("lockfile.get_locked/set_locked");

    test("gets and sets locked entry", fn() {
        let lock = lockfile.create_empty();
        let entry = lockfile.create_entry("1.0.0", "url", "hash", null);

        lock = lockfile.set_locked(lock, "owner/pkg", entry);
        let retrieved = lockfile.get_locked(lock, "owner/pkg");

        assert_not_null(retrieved, "entry exists");
        assert_eq(retrieved.version, "1.0.0", "version matches");
    });

    test("returns null for missing entry", fn() {
        let lock = lockfile.create_empty();
        let entry = lockfile.get_locked(lock, "nonexistent/pkg");
        assert_null(entry, "should be null");
    });

    suite("lockfile.remove_locked");

    test("removes entry", fn() {
        let lock = lockfile.create_empty();
        let entry = lockfile.create_entry("1.0.0", "url", "hash", null);
        lock = lockfile.set_locked(lock, "owner/pkg", entry);

        lock = lockfile.remove_locked(lock, "owner/pkg");
        let retrieved = lockfile.get_locked(lock, "owner/pkg");

        assert_null(retrieved, "entry removed");
    });

    suite("lockfile.get_locked_names");

    test("returns all names", fn() {
        let lock = lockfile.create_empty();
        lock = lockfile.set_locked(lock, "owner/a", lockfile.create_entry("1.0.0", "", "", null));
        lock = lockfile.set_locked(lock, "owner/b", lockfile.create_entry("2.0.0", "", "", null));

        let names = lockfile.get_locked_names(lock);
        assert_eq(names.length, 2, "two entries");
    });

    test("returns empty for new lockfile", fn() {
        let lock = lockfile.create_empty();
        let names = lockfile.get_locked_names(lock);
        assert_eq(names.length, 0, "no entries");
    });

    suite("lockfile.needs_update");

    test("needs update when no lockfile", fn() {
        let deps = {};
        deps["owner/pkg"] = "^1.0.0";
        let manifest = { dependencies: deps };
        assert_true(lockfile.needs_update(null, manifest), "needs update");
    });

    test("needs update when dep missing", fn() {
        let lock = lockfile.create_empty();
        let deps = {};
        deps["owner/pkg"] = "^1.0.0";
        let manifest = { dependencies: deps };
        assert_true(lockfile.needs_update(lock, manifest), "needs update");
    });

    test("no update when all deps locked", fn() {
        let lock = lockfile.create_empty();
        lock = lockfile.set_locked(lock, "owner/pkg", lockfile.create_entry("1.0.0", "", "", null));

        let deps = {};
        deps["owner/pkg"] = "^1.0.0";
        let manifest = { dependencies: deps, devDependencies: null };
        assert_false(lockfile.needs_update(lock, manifest), "no update needed");
    });

    suite("lockfile.prune");

    test("prune returns empty when lockfile is null", fn() {
        let prune_result1 = lockfile.prune(null, { dependencies: {} });
        assert_eq(prune_result1.removed.length, 0, "no removed");
    });

    test("prune keeps direct dependencies", fn() {
        let lock2 = lockfile.create_empty();
        lock2 = lockfile.set_locked(lock2, "owner/a", lockfile.create_entry("1.0.0", "", "", null));
        lock2 = lockfile.set_locked(lock2, "owner/b", lockfile.create_entry("2.0.0", "", "", null));

        let deps2 = {};
        deps2["owner/a"] = "^1.0.0";
        deps2["owner/b"] = "^2.0.0";
        let manifest2 = { dependencies: deps2, devDependencies: null };

        let prune_result2 = lockfile.prune(lock2, manifest2);
        assert_eq(prune_result2.removed.length, 0, "nothing removed");
        assert_not_null(lockfile.get_locked(prune_result2.lockfile, "owner/a"), "a still exists");
        assert_not_null(lockfile.get_locked(prune_result2.lockfile, "owner/b"), "b still exists");
    });

    test("prune removes orphaned packages", fn() {
        let lock3 = lockfile.create_empty();
        lock3 = lockfile.set_locked(lock3, "owner/a", lockfile.create_entry("1.0.0", "", "", null));
        lock3 = lockfile.set_locked(lock3, "owner/orphan", lockfile.create_entry("1.0.0", "", "", null));

        let deps3 = {};
        deps3["owner/a"] = "^1.0.0";
        let manifest3 = { dependencies: deps3, devDependencies: null };

        let prune_result3 = lockfile.prune(lock3, manifest3);
        assert_eq(prune_result3.removed.length, 1, "one removed");
        assert_eq(prune_result3.removed[0], "owner/orphan", "orphan was removed");
        assert_not_null(lockfile.get_locked(prune_result3.lockfile, "owner/a"), "a still exists");
        assert_null(lockfile.get_locked(prune_result3.lockfile, "owner/orphan"), "orphan removed");
    });

    test("prune keeps transitive dependencies", fn() {
        let trans_deps4 = {};
        trans_deps4["owner/trans"] = "^1.0.0";
        let lock4 = lockfile.create_empty();
        lock4 = lockfile.set_locked(lock4, "owner/a", lockfile.create_entry("1.0.0", "", "", trans_deps4));
        lock4 = lockfile.set_locked(lock4, "owner/trans", lockfile.create_entry("1.0.0", "", "", null));

        let deps4 = {};
        deps4["owner/a"] = "^1.0.0";
        let manifest4 = { dependencies: deps4, devDependencies: null };

        let prune_result4 = lockfile.prune(lock4, manifest4);
        assert_eq(prune_result4.removed.length, 0, "nothing removed");
        assert_not_null(lockfile.get_locked(prune_result4.lockfile, "owner/a"), "a still exists");
        assert_not_null(lockfile.get_locked(prune_result4.lockfile, "owner/trans"), "trans still exists");
    });

    test("prune removes orphaned transitive deps", fn() {
        let lock5 = lockfile.create_empty();
        lock5 = lockfile.set_locked(lock5, "owner/a", lockfile.create_entry("1.0.0", "", "", null));
        lock5 = lockfile.set_locked(lock5, "owner/trans", lockfile.create_entry("1.0.0", "", "", null));

        let deps5 = {};
        deps5["owner/a"] = "^1.0.0";
        let manifest5 = { dependencies: deps5, devDependencies: null };

        let prune_result5 = lockfile.prune(lock5, manifest5);
        assert_eq(prune_result5.removed.length, 1, "one removed");
        assert_eq(prune_result5.removed[0], "owner/trans", "trans was removed");
    });

    test("prune handles devDependencies", fn() {
        let lock6 = lockfile.create_empty();
        lock6 = lockfile.set_locked(lock6, "owner/prod", lockfile.create_entry("1.0.0", "", "", null));
        lock6 = lockfile.set_locked(lock6, "owner/dev", lockfile.create_entry("1.0.0", "", "", null));

        let deps6 = {};
        deps6["owner/prod"] = "^1.0.0";
        let devDeps6 = {};
        devDeps6["owner/dev"] = "^1.0.0";
        let manifest6 = { dependencies: deps6, devDependencies: devDeps6 };

        let prune_result6 = lockfile.prune(lock6, manifest6);
        assert_eq(prune_result6.removed.length, 0, "nothing removed");
        assert_not_null(lockfile.get_locked(prune_result6.lockfile, "owner/prod"), "prod still exists");
        assert_not_null(lockfile.get_locked(prune_result6.lockfile, "owner/dev"), "dev still exists");
    });

    test("prune handles deep transitive chain", fn() {
        let b_deps7 = {};
        b_deps7["owner/c"] = "^1.0.0";
        let c_deps7 = {};
        c_deps7["owner/d"] = "^1.0.0";
        let a_deps7 = {};
        a_deps7["owner/b"] = "^1.0.0";

        let lock7 = lockfile.create_empty();
        lock7 = lockfile.set_locked(lock7, "owner/a", lockfile.create_entry("1.0.0", "", "", a_deps7));
        lock7 = lockfile.set_locked(lock7, "owner/b", lockfile.create_entry("1.0.0", "", "", b_deps7));
        lock7 = lockfile.set_locked(lock7, "owner/c", lockfile.create_entry("1.0.0", "", "", c_deps7));
        lock7 = lockfile.set_locked(lock7, "owner/d", lockfile.create_entry("1.0.0", "", "", null));

        let deps7 = {};
        deps7["owner/a"] = "^1.0.0";
        let manifest7 = { dependencies: deps7, devDependencies: null };

        let prune_result7 = lockfile.prune(lock7, manifest7);
        assert_eq(prune_result7.removed.length, 0, "nothing removed");
        assert_not_null(lockfile.get_locked(prune_result7.lockfile, "owner/a"), "a exists");
        assert_not_null(lockfile.get_locked(prune_result7.lockfile, "owner/b"), "b exists");
        assert_not_null(lockfile.get_locked(prune_result7.lockfile, "owner/c"), "c exists");
        assert_not_null(lockfile.get_locked(prune_result7.lockfile, "owner/d"), "d exists");
    });
}
